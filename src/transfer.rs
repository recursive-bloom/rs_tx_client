use std::path::PathBuf;
use std::str::FromStr;

use parity_crypto::Keccak256;
use parity_crypto::publickey::ec_math_utils;
use parity_crypto::publickey::public_to_address;
use parity_crypto::publickey::{Generator, Random, Secret};
use web3::types::{TransactionRequest, U256};

use crate::errors::Error;
use crate::key;

pub struct Transfer {
    nonce_point_x: U256,
    nonce_point_y: U256,
    nonce_point_compressed: String,
    tx_hash: String,
}

pub fn transfer(
    mut from_path: &mut PathBuf,
    from_address: &str,
    to: &str
) -> Result<Transfer, Error> {
    let (_eloop, transport) = web3::transports::Http::new("http://127.0.0.1:8545").unwrap();

    let web3 = web3::Web3::new(transport);

    // parse recipient's public key and address
    // create a copy to use for EC math
    let (public_key, address) = key::public_key_from_str(to)?;

    // generate random nonce and calculate nonce point
    // nonce point is then shared with the recipient
    let nonce = Random.generate().secret().clone();
    let mut nonce_point = ec_math_utils::generation_point();
    ec_math_utils::public_mul_secret(&mut nonce_point, &nonce)?;

    // generate ECDH shared secret
    // this secret can also be generated by Recipient
    // with the knowledge of the above `nonce_point`
    let mut ecdh_shared_secret = public_key.clone();
    ec_math_utils::public_mul_secret(&mut ecdh_shared_secret, &nonce)?;
    let ecdh_shared_secret_hash = ecdh_shared_secret.keccak256();

    // get the secret number from ecdh secret's hash
    // calculate recipient's address
    let secret_number = Secret::from_str(&hex::encode(ecdh_shared_secret_hash))?;
    let mut recipient_public_key = ec_math_utils::generation_point();
    ec_math_utils::public_mul_secret(&mut recipient_public_key, &secret_number)?;
    let recipient_address = public_to_address(&recipient_public_key);
    println!("recipient address = {:?}", recipient_address);

    // broadcast transaction
    todo!();

    Err(Error::Custom(String::from("[transfer] dummy error")))
}
