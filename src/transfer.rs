use std::path::PathBuf;
use std::str::FromStr;

use parity_crypto::Keccak256;
use parity_crypto::publickey::ec_math_utils;
use parity_crypto::publickey::public_to_address;
use parity_crypto::publickey::{Generator, Random, Secret};

use secp256k1::PublicKey;

use ethereum_tx_sign::RawTransaction;

use web3::futures::Future;
use web3::types::{Bytes, H160, H256, U256};

use crate::errors::Error;
use crate::key;
use crate::utils::{convert_h160, convert_h256};

pub struct Transfer {
    pub nonce_point_x: U256,
    pub nonce_point_y: U256,
    pub nonce_point_compressed: PublicKey,
    pub tx_hash: H256,
}

pub fn transfer(
    mut from_path: &mut PathBuf,
    from_address: &str,
    to: &str,
    value: &str
) -> Result<Transfer, Error> {
    // instantiate web3
    let (_eloop, transport) = web3::transports::Http::new("http://127.0.0.1:8545").unwrap();
    let web3 = web3::Web3::new(transport);

    // parse recipient's public key and address
    // create a copy to use for EC math
    let (public_key, address) = key::public_key_from_str(to)?;

    // generate random nonce and calculate nonce point
    // nonce point is then shared with the recipient
    let nonce = Random.generate().secret().clone();
    let mut nonce_point = ec_math_utils::generation_point();
    ec_math_utils::public_mul_secret(&mut nonce_point, &nonce)?;
    let nonce_point_compressed = key::to_secp256k1_public(&nonce_point)?;

    // generate ECDH shared secret
    // this secret can also be generated by Recipient
    // with the knowledge of the above `nonce_point`
    let mut ecdh_shared_secret = public_key.clone();
    ec_math_utils::public_mul_secret(&mut ecdh_shared_secret, &nonce)?;
    let ecdh_shared_secret_hash = ecdh_shared_secret.keccak256();

    // get the secret number from ecdh secret's hash
    // calculate recipient's address
    let secret_number = Secret::from_str(&hex::encode(ecdh_shared_secret_hash))?;
    let mut recipient_public_key = ec_math_utils::generation_point();
    ec_math_utils::public_mul_secret(&mut recipient_public_key, &secret_number)?;
    ec_math_utils::public_add(&mut recipient_public_key, &public_key)?;
    let recipient_address = public_to_address(&recipient_public_key);
    println!("recipient address = {:?}", recipient_address);

    // broadcast transaction
    let sender_keypair = key::load(&mut from_path, &from_address)?;
    let transfer_nonce = web3.eth().transaction_count(convert_h160(sender_keypair.address()), None).wait().unwrap();
    if let Ok(u256_value) = U256::from_dec_str(value) {
        let tx = RawTransaction {
            nonce: transfer_nonce,
            to: Some(convert_h160(recipient_address)),
            value: u256_value,
            gas_price: U256::from("10000000000"),
            gas: U256::from("21000"),
            data: Vec::new()
        };
        let chain_id = web3.eth().chain_id().wait().unwrap().as_u64();
        let signed_tx = tx.sign(&convert_h256(sender_keypair.secret()), &chain_id);
        let tx_hash = web3.eth().send_raw_transaction(Bytes::from(signed_tx)).wait().unwrap();

        let (nonce_point_x, nonce_point_y) = decompose_public_key(&nonce_point_compressed);
        let transfer = Transfer {
            nonce_point_x: U256::from(nonce_point_x),
            nonce_point_y: U256::from(nonce_point_y),
            nonce_point_compressed: nonce_point_compressed,
            tx_hash: tx_hash
        };

        Ok(transfer)
    } else {
        Err(Error::Custom(String::from("[value] could not be parsed")))
    }
}

fn decompose_public_key(public_key: &PublicKey) -> ([u8; 32], [u8; 32]) {
    let public_key_bytes = public_key.serialize_uncompressed();
    let mut public_key_x = [0u8; 32];
    let mut public_key_y = [0u8; 32];
    (&mut public_key_x[0..32]).copy_from_slice(&public_key_bytes[1..33]);
    (&mut public_key_y[0..32]).copy_from_slice(&public_key_bytes[33..65]);

    (public_key_x, public_key_y)
}
